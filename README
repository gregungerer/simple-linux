Simple-Linux
------------

Simple-linux is a set of scripts for simply and quickly building a runnable
embedded linux system. It is targeted at generating the simplest possible
system that can be run on various architecture and machine QEMU emulations.

Initially is support for generating a non-MMU based ColdFire/M5208EVB
linux image. It runs in QEMU or can be run on real hardware. Next was
added support for building ELF based m68knommu systems, then support for
building an ARM nommu system as well. The latest addition is for building
a minimal RIS-V based system. More will follow over time.

This is designed to be as absolutely simple and minimal as possible.
Only the first stage gcc is built (that is all we really need) and
only the busybox package to provide a very basic user space. There are
many fully fledged build systems out there, but these scripts are designed
to be the absolute simplest possible build. The idea is that it shows
the core requirements (or from scratch if you like) procedure in building
a running system. QEMU provides the perfect means to try out the build.

The build starts by building binutils and a first pass minimal gcc,
then builds uClibc (or musl as appropriate), busybox and finally a kernel.
All source packages will be downloaded if not already present locally.
The resulting kernel can be run using QEMU.



M68K nommu
----------

The traditional m68knommu build uses flat format executables. So the
simplest and most strait forward build uses that. Once you have installed
the simple-linux files locally, run the build script:

    ./build-m68knommu-linux-uclibc-flt.sh

and then run the resulting system:

   qemu-system-m68k -nographic -machine mcf5208evb -kernel linux-6.0/vmlinux

There is also now an experimental build using ELF format executables.
You can try that out with:

    ./build-m68knommu-linux-uclibc-elf.sh

It can be run with same QEMU command line as above.



ARM
---

QEMU has a nice ARM/versatile board emulation that is ideal for testing
simple ARM systems. 

    ./build-arm-linux-musl-elf.sh

and then run the resulting system:

    qemu-system-arm -M versatilepb -nographic -kernel linux-6.0/arch/arm/boot/zImage -dtb linux-6.0/arch/arm/boot/dts/versatile-pb.dtb -append "console=ttyAMA0,115200"

There is also a uclibc based ARM build:

    ./build-arm-linux-uclibc-elf.sh

Run with the same qemu command line above.



ARM nommu
---------

QEMU has a nice ARM/versatile board emulation that is ideal for testing
no-mmu ARM systems. The catch is that the kernel support for versatile
running with no MMU has been broken for a few years now. It is easy to
fix up with a patch, and that is included here. For a simple flat format
build:

    ./build-armnommu-linux-uclibc-flt.sh

and then run the resulting system:

    qemu-system-arm -M versatilepb -nographic -kernel linux-6.0/arch/arm/boot/zImage -dtb linux-6.0/arch/arm/boot/dts/versatile-pb.dtb -append "console=ttyAMA0,115200"



RISC-V
------

QEMU has a nice generic RISC-V based system emulation that is ideal for
testing RISC-V based Linux systems. This build uses the musl C-library
instead of uClibc, but is otherwise similar to the other simple Linux
builds. Build with:

    ./build-riscv-linux-musl-elf.sh

and then run the resulting system:

    qemu-system-riscv64 -nographic -machine virt -bios opensbi/build/platform/generic/firmware/fw_jump.elf -kernel linux-6.0/arch/riscv/boot/Image -append "console=ttyS0"

Or alternatively you can do a build using uClibc instead of musl with:

    ./build-riscv-linux-uclibc-elf.sh

Run with the same QEMU command line as above.



RISC-V nommu
------------

There is now an experimental RISC-V nommu build that supports ELF format
binaries. Note this is not ELF-FDPIC, but rather PIE style ELF binaries -
but it does use the linux kernels ELF-FDPIC program loader.
To build that:

    ./build-riscvnommu-linux-uclibc-elf.sh

and then run the resulting system:

    qemu-system-riscv64 -cpu rv64,mmu=false -nographic -machine virt -bios linux-6.1/arch/riscv/boot/Image

